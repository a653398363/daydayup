import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as e}from"./app-R7pVbBlq.js";const t="/assets/browerI-BJtTVVCm.png",i="/assets/taskOrder-CscdSBb7.png",o="/assets/eventRecui-D47xlVTu.png",p="/assets/principleJs-BCyFjxFz.png",l={},c=e('<h1 id="浏览器相关原理" tabindex="-1"><a class="header-anchor" href="#浏览器相关原理"><span>浏览器相关原理</span></a></h1><h2 id="浏览器是多进程" tabindex="-1"><a class="header-anchor" href="#浏览器是多进程"><span>浏览器是多进程</span></a></h2><p>进程是 CPU 分配资源的最小单位</p><ul><li><p>Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p><ol><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ol></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p></li><li><p>GPU 进程：最多一个，用于 3D 绘制等</p></li><li><p>浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为</p></li></ul><p>页面渲染，脚本执行，事件处理等 <img src="'+t+'" alt="浏览器" loading="lazy"></p><h3 id="浏览器渲染进程-浏览器内核" tabindex="-1"><a class="header-anchor" href="#浏览器渲染进程-浏览器内核"><span>浏览器渲染进程（浏览器内核）</span></a></h3><ul><li><p>GUI 渲染线程</p><p>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p></li><li><p>JS 引擎线程</p><p>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） JS 引擎线程负责解析 Javascript 脚本，运行代码。 JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li><li><p>事件触发线程</p><p>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助） 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</p></li><li><p>定时触发器线程</p><p>传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行） 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</p></li><li><p>异步 http 请求线程</p><p>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</p></li></ul><h2 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h2><p>JavaScript 的任务分为 <code>同步</code> 和 <code>异步</code></p><p><img src="'+i+'" alt="浏览器" loading="lazy"></p><ul><li><p>同步任务： 同步任务都在<strong>主线程(JS 引擎)<strong>上执行，形成一个</strong>执行栈</strong>，在主线程上排队执行的任务，只有一个任务执行完毕才能执行下一个任务！</p></li><li><p>异步任务： <strong>事件触发线程</strong>管理着<strong>任务队列</strong>，异步任务不进入主线程，将异步任务压入事件任务队列，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程执行调用执行栈的任务。</p></li></ul><p><img src="'+o+`" alt="事件循环" loading="lazy"></p><p>主线程运行时会产生执行栈， 栈中的代码调用某些 api 时，它们会在事件队列中添加各种事件（当满足触发条件后，如 ajax 请求完毕）</p><p>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 如此循环，这就是事件循环 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</p><h3 id="宏任务和微任务" tabindex="-1"><a class="header-anchor" href="#宏任务和微任务"><span>宏任务和微任务</span></a></h3><p>任务队列其实不止一种，根据任务种类的不同，可以分为**微任务（micro task）<strong>队列和</strong>宏任务（macro task）**队列。常见的任务如下：</p><ul><li>宏任务： script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)。 <ul><li>每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li><li>每一个 task 会从头到尾将这个任务执行完毕，不会执行其它 浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 <code>（</code>task-&gt;渲染-&gt;task-&gt;...<code>）</code></li></ul></li><li>微任务： Promise、MutaionObserver、process.nextTick(Node.js 环境)。 <ul><li>可以理解是在当前 task 执行结束后立即执行的任务</li><li>也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前 所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染 也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</li></ul></li></ul><p>根据线程来理解:</p><ul><li>macrotask 中的事件都是放在一个事件队列中的，而这个队列由<strong>事件触发线程</strong>维护</li><li>microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由<strong>JS 引擎线程</strong>维护</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;同步代码1&#39;</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;setTimeout&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;同步代码2&#39;</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise.then&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise.then2&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;同步代码3&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码输出结果如下:</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token string">&#39;同步代码1&#39;</span>
<span class="token string">&#39;同步代码2&#39;</span>
<span class="token string">&#39;同步代码3&#39;</span>
<span class="token string">&#39;promise.then&#39;</span>
<span class="token string">&#39;promise.then2&#39;</span>
<span class="token string">&#39;setTimeout&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>遇到第一个 console，它是同步代码，加入执行栈，执行并出栈，打印出&quot;同步代码 1&quot;。</li><li>遇到 setTimeout，它是一个宏任务，加入宏任务队列。</li><li>遇到 new Promise 中的 console，它是同步代码，加入执行栈，执行并出栈，打印出&quot;同步代码 2&quot;。</li><li>遇到 Promise then，它是一个微任务，promise.then2 也执行，加入微任务队列, 。</li><li>遇到第三个 console，它是同步代码，加入执行栈，执行并出栈，打印出&quot;同步代码 3&quot;。</li><li>此时执行栈为空，去执行微任务队列中所有任务，打印出&quot;promise.then&quot;。</li><li>执行完微任务队列中的任务，就去执行宏任务队列中的一个任务，打印出&quot;setTimeout&quot;。</li></ol><h4 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制"><span>运行机制</span></a></h4><p><img src="`+p+'" alt="network architecture 1" loading="lazy"></p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li><li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><h2 id="refenrence" tabindex="-1"><a class="header-anchor" href="#refenrence"><span>refenrence</span></a></h2><p><a href="https://web.dev/howbrowserswork/" target="_blank" rel="noopener noreferrer">How browsers work</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noopener noreferrer">browsers_work</a></p>',28),r=[c];function u(d,m){return s(),a("div",null,r)}const v=n(l,[["render",u],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/Front/browser/","title":"浏览器相关原理","lang":"zh-CN","frontmatter":{"icon":"frame","category":["Brower"],"tag":["Interview"],"description":"浏览器相关原理 浏览器是多进程 进程是 CPU 分配资源的最小单位 Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的...","head":[["meta",{"property":"og:url","content":"https://lfange.github.io/Front/browser/"}],["meta",{"property":"og:site_name","content":"哓番茄"}],["meta",{"property":"og:title","content":"浏览器相关原理"}],["meta",{"property":"og:description","content":"浏览器相关原理 浏览器是多进程 进程是 CPU 分配资源的最小单位 Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-29T13:35:43.000Z"}],["meta",{"property":"article:author","content":"哓番茄"}],["meta",{"property":"article:tag","content":"Interview"}],["meta",{"property":"article:modified_time","content":"2023-03-29T13:35:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器相关原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-29T13:35:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"哓番茄\\",\\"url\\":\\"https://lfange.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"浏览器是多进程","slug":"浏览器是多进程","link":"#浏览器是多进程","children":[{"level":3,"title":"浏览器渲染进程（浏览器内核）","slug":"浏览器渲染进程-浏览器内核","link":"#浏览器渲染进程-浏览器内核","children":[]}]},{"level":2,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[{"level":3,"title":"宏任务和微任务","slug":"宏任务和微任务","link":"#宏任务和微任务","children":[]}]},{"level":2,"title":"refenrence","slug":"refenrence","link":"#refenrence","children":[]}],"git":{"createdTime":1662472538000,"updatedTime":1680096943000,"contributors":[{"name":"FanGe","email":"653398363@qq.com","commits":5},{"name":"fange","email":"653398363@qq.com","commits":3}]},"readingTime":{"minutes":6.7,"words":2010},"filePathRelative":"Front/browser/README.md","localizedDate":"2022年9月6日","excerpt":"","autoDesc":true}');export{v as comp,h as data};
