<!--
 * @Author: fange 653398363@qq.com
 * @Date: 2023-02-07 09:53:15
 * @LastEditors: fange 653398363@qq.com
 * @LastEditTime: 2023-02-13 10:27:11
 * @FilePath: \lfange.github.io\code\test.html
 * @Description: personal written
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      function depClone(source) {
        if (source instanceof Object === false) return source
      }

      const arr = [
        {
          id: 2,
          name: '部门B',
          pid: 0,
        },
        {
          id: 3,
          name: '部门C',
          pid: 1,
        },
        {
          id: 1,
          name: '部门A',
          pid: 2,
        },
        {
          id: 4,
          name: '部门D',
          pid: 1,
        },
        {
          id: 5,
          name: '部门E',
          pid: 2,
        },
        {
          id: 6,
          name: '部门F',
          pid: 3,
        },
        {
          id: 7,
          name: '部门G',
          pid: 2,
        },
        {
          id: 8,
          name: '部门H',
          pid: 4,
        },
      ]

      function getChildren(arr, id) {
        const res = []
        arr.map((item) => {
          if (item.pid === id) {
            res.push({
              ...item,
              children: getChildren(arr, item.id),
            })
          }
        })
        return res
      }

      const tree = getChildren(arr, 0)

      console.log('getChildren', tree)

      function toArr(data) {
        let arr = []

        const recle = (ite) => {
          if (ite.children && ite.children.length) {
            ite.children.forEach((it) => {
              recle(it)
            })
          }
          delete ite.children
          arr.push({
            ...ite,
          })
        }
        if (data.children.length) {
          recle(data)
        }

        console.log('arr', arr)
      }
      console.log('toArr', toArr(...tree))

      function fn(obj, res = []) {
        // 默认初始结果数组为[]
        res.push(obj) // 当前元素入栈
        // 若元素包含children，则遍历children并递归调用使每一个子元素入栈
        if (obj.children && obj.children.length) {
          for (const item of obj.children) {
            fn(item, res)
          }
        }
        return res
      }

      console.log('fn', fn(...tree))

      function toTree(data) {
        // 删除 所有 children,以防止多次调用
        data.forEach(function (item) {
          delete item.children
        })
        // 将数据存储为 以 id 为 KEY 的 map 索引数据列
        var map = {}
        data.forEach(function (item) {
          item.label = item.DWJC
          map[item.DWDM] = item
        })
        var val = []
        data.forEach(function (item) {
          // 以当前遍历项，的pid,去map对象中找到索引的id
          var parent = map[item.SJDWBM]
          // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中
          if (parent) {
            ;(parent.children || (parent.children = [])).push(item)
          } else {
            //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级
            val.push(item)
          }
        })
        if (val.length > 1) {
          for (var i = 1; i < val.length; i++) {
            val[0].children.push(val[i])
          }
          val.splice(1)
        }
        return val
      }
    </script>
  </body>
</html>
